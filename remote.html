<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>WebRTC Scalable Broadcast System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
  <link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css"
  integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w=="
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/javascript.util/0.12.12/javascript.util.min.js"></script>
  <style>
    
    video {
      display: block;
    }
    
    section {
      opacity: 1;
      transition: opacity 500ms ease-in-out;
    }
  
   
  .invisible {
    opacity: 0.2;
  }
  
    .camView {
      position: relative;
      float: left;
      width: calc(100% - 20px);
      margin: 10px;
      cursor: pointer;
    }
  
    
    .camView p {
      position: absolute;
      padding: 5px;
      background-color: rgba(255, 111, 0, 0.85);
      color: #FFF;
      border: 1px dashed rgba(255, 255, 255, 0.7);
      z-index: 2;
      font-size: 12px;
    }
    
    .highlighter {
      background: rgba(0, 255, 0, 0.25);
      border: 1px dashed #fff;
      z-index: 1;
      position: absolute;
    }

  .bottom-container {
  max-width: 960px;
  margin: auto;
  padding: 10px;
  }

    #photos {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-gap: 10px;
    }

    #photos img {
    width: 100%;
    border-radius: 10px;
    border:1px solid whitesmoke;
   
    }

    #canvas {
    display: none;
    }

    #overlay-canvas {
      position: absolute;
      top: 10px;
      left: 10px;
      font: 18px Arial;
      color: white;
      z-index: 999;
    }

    #canvas_face{
      position: absolute;
      top: 10px;
      left: 10px;
      
      
      z-index: 999;
    }
  </style>

</head>
<body class="text-white text-bg-dark">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
          <a class="navbar-brand  text-white text-bg-dark" href="https://eie4428miniproject.netlify.app/">EIE4428 Mini Project</a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
          </button>
          <div class="collapse navbar-collapse" id="navbarText">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
              <li class="nav-item ">
                <span class="nav-link active  text-white text-bg-dark">Leung Wui Hang</span>
              </li>
              <li class="nav-item">
                <span class="nav-link active  text-white text-bg-dark">Kevin kwok</span>
              </li>
             
            </ul>
            
          </div>
        </div>
      </nav>

  <div class="alert alert-warning alert-dismissible fade show" role="alert">
  <strong>Notice</strong> It is suggested to use Chrome browser.
  <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
</div>
  
  <h1 class=" text-center">

    <p class="no-mobile">
        WebRTC Scalable Broadcast System
    </p>
  </h1>
  <br />
<div class="container">

<div class="accordion d-none" id="accordionExample">
    <div class="accordion-item">
      
        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
          Text Broadcast
        </button>
      
      <div id="collapseOne" class="accordion-collapse collapse show" data-bs-parent="#accordionExample">
        <div class="accordion-body" id="message_content">
          

        </div>
        <br/>
        <button class="btn btn-primary" id="clear_message">Clear</button>
      </div>
    </div>   
  </div>


  
  <div class="row">
    <div class="col-12 col-md-8">
      
      
      <!--loading icon if content not fully loaded-->
          <div class="d-flex justify-content-center" id="loading">
            <div class="spinner-border" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
      
        <section class="make-center invisible" id="demos">
            <p style="margin: 0; padding: 0; padding-bottom: 20px;">

          
                 <div class="container">
                            <span>Supported Codec in your device:</span>
                            <select id="codecPreferences" class="form-select" disabled>
                                <option selected value="">Codec Lists</option>
                            </select>
                        </div>
                        <br/>
              
                <div class="make-center">
                
                <div class="input-group">
                    <span class="input-group-text">Broadcast ID</span>
                   
                    <input class="text-black form-control" type="text" id="broadcast-id" value="eie4428-project" autocorrect=off autocapitalize=off size=20 disabled >
                    <button class="btn btn-primary" id="open-or-join">Join Broadcast</button>
                </div>


                <div class="make-center" id="broadcast-viewers-counter-guest"></div>
            </p>
            <div id="liveView" class="camView" style="display: inline-block;">
              <video id="videoOutput" playsinline  controls loop width="100%" height="100%" ></video>
              <canvas id="canvas_face" width="100%" height="100%" ></canvas>
              <video id="video-preview" playsinline controls loop  width="100%" height="100%" hidden></video>
              <canvas id="overlay-canvas" width="100%" height="100%" hidden></canvas>
            
            <br/>

            <button id="photo-button" class="btn btn-success mt-1">
                <i class="fa-solid fa-camera"></i> Take Photo
            </button>

            <button id="disconnect-button" class="btn btn-danger mt-1">
                 Disconnect
            </button>

            <button id="recording" class="btn btn-primary mt-1" disabled>
                Recording
               <div class="spinner-grow spinner-grow-sm text-danger d-none" role="status" id="spinner-grow">
                  <span class="visually-hidden">Loading...</span>
                </div>
           </button>

           <button id="stoprecording" class="btn btn-primary mt-1" disabled>
            Stop Recording
           </button>
              
           <button id="showrecording" class="btn btn-primary mt-1" disabled>
            Show Recording
           </button>

          <button id="showAllrecording" class="btn btn-primary mt-1" type="button" data-bs-toggle="collapse" data-bs-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">
            Show All Recording
          </button>
  
        <div class="collapse" id="collapseExample">
          <div class="card card-body text-dark" id="recording_content">
            No record. (Try to click "Show Recording" first)
          </div>
        </div>
           
           <video id="video-record" playsinline  controls loop muted class="d-none"></video>
              <hr>
            <canvas id="canvas"></canvas>
            <div class="bottom-container">
              

                <div id="photos"></div>
                <hr>
               
              </div>
            </div>
        </section>
    </div>

    <div class="col-12 col-md-4" style="z-index: 9999;">
        <h2>Basic camera setting</h2>
        <div class="accordion" id="accordionPanelsStayOpenExample" disabled>
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseOne" aria-expanded="true" aria-controls="panelsStayOpen-collapseOne">
                 Camera Resolution
                </button>
              </h2>
             
              <div id="panelsStayOpen-collapseOne" class="accordion-collapse collapse show">
                <div class="accordion-body">
                    <p id="initial_WH">Previous Width=? ; Previous Height=?</p>
                 <p>W:   <input class="form-control" type="text" id="vid-width" value="600"></p>
                 <p>H: <input  class="form-control" type="text" id="vid-height" value="600"></p>
                
                 <button id="change-size" class="btn btn-primary mb-1" disabled>Change screen size</button>
                 <button id="reset-size" class="btn btn-primary mb-1" disabled>Reset default size</button>
                </div>
              </div>
            </div>
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseTwo" aria-expanded="false" aria-controls="panelsStayOpen-collapseTwo">
                  Camera Filter
                </button>
              </h2>
              <div id="panelsStayOpen-collapseTwo" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <select id="photo-filter" class="form-select" aria-label="Default select example" disabled>
                        <option selected value="none">Normal</option>
                        <option value="grayscale(100%)">Grayscale</option>
                        <option value="sepia(100%)">Sepia</option>
                        <option value="invert(100%)">Invert</option>        
                        <option value="hue-rotate(90deg)">Hue</option>
                        <option value="blur(10px)">Blur</option>
                        <option value="contrast(200%)">Contrast</option>
                        <option value="brightness(50%)">Brightness 50</option>
                        <option value="opacity(50%)">Opacity 50</option>
                        <option value="saturate(50%)">Saturate 50</option>
                      </select>
                      <br/>
                      <button id="clear-button" class="btn btn-primary" disabled>Clear Image and Filter</button>
                </div>
              </div>
            </div>
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseThree" aria-expanded="false" aria-controls="panelsStayOpen-collapseThree">
                    Camera Filter (Advanced)
                </button>
              </h2>
              <div id="panelsStayOpen-collapseThree" class="accordion-collapse collapse">
                <div class="accordion-body">
                    <form id="photo-filter-advanced">
                        <label for="grayscale">Grayscale (between 0% and 100%):</label>
                        <input type="range" id="grayscale" name="grayscale" min="1" max="100" value="1" disabled>
                        <label for="sepia">Sepia (between 0% and 100%):</label>
                        <input type="range" id="sepia" name="sepia" min="1" max="100" value="1" disabled>
                        <label for="invert">Invert (between 0% and 100%):</label>
                        <input type="range" id="invert" name="invert" min="1" max="100" value="1" disabled>
                        <label for="brightness">Brightness (between 0% and 100%):</label>
                        <input type="range" id="brightness" name="brightness" min="1" max="100" value="100" disabled>
                        <label for="opacity">Opacity (between 0% and 100%):</label>
                        <input type="range" id="opacity" name="opacity" min="1" max="100" value="100" disabled>
                        <label for="contrast">Contrast (between 0% and 1000%):</label>
                        <input type="range" id="contrast" name="contrast" min="1" max="1000" value="100" disabled>
                        <label for="saturate">Saturate (between 0% and 1000%):</label>
                        <input type="range" id="saturate" name="saturate" min="1" max="1000" value="100" disabled>
                        
                    </form>
                      <br/>
                      <button id="clear-button2" class="btn btn-primary" disabled>Clear Image and Filter</button>
                </div>
              </div>
            </div>
          </div>

        <hr>
        <h2>Advanced features</h2>
        <button id="objectRecognizeOn" class="btn btn-primary mb-2" disabled>Open Object Recognition</button>
        <button id="objectRecognizeOff" class="btn btn-secondary mb-2" disabled>Close Object Recognition</button>  
        <br/>
        <button id="FaceTrackingOn" class="btn btn-primary mb-1" disabled>Open Face Tracking</button>
        <button id="FaceTrackingOff" class="btn btn-secondary mb-1" disabled>Close Face Tracking</button>  
    </div>
  </div>
</div> 

 <!-- Bootstrap--> 
 <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
  <script src="https://muazkhan.com:9001/dist/RTCMultiConnection.min.js"></script>
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script src="https://muazkhan.com:9001/socket.io/socket.io.js"></script>
<!-- Import TensorFlow.js library -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js" type="text/javascript"></script>
<!-- Load the coco-ssd model to use to recognize things in images -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

 <script src="level1.js"></script>
 <script src="https://www.webrtc-experiment.com/RecordRTC.js"></script> 

 <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
 <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

 <!-- <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>-->
 <!-- Optional: Include below scripts if you want to use MediaPipe runtime. -->
 <!--  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"> </script> -->
 

<!-- <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.js"></script>
<script src="https://unpkg.dev/@vladmandic/face-api/dist/face-api.js"></script>-->
   <script src="CodecsHandler.js"></script>
<script>
// recording is disabled because it is resulting for browser-crash
// if you enable below line, please also uncomment above "RecordRTC.js"
var enableRecordings = true;

var connection = new RTCMultiConnection();

//connection.codecs.video  = 'H264';
  connection.codecs.video  = 'VP9';

  //connection.processSdp = function(sdp) {
   // CodecsHandler.preferCodec(sdp, 'h264');
   // sdp =    CodecsHandler.prioritize('video/VP9');
  //  return sdp;
//};
  
let roomopened = true;
  
// to get both STUN and TURN candidate pairs
connection.iceTransportPolicy = 'all';

connection.candidates = {
    turn: true,
    stun: true,
    host: false
};  
  
// first step, ignore default STUN+TURN servers
connection.iceServers = [];

// last step, set TURN url (recommended)
connection.iceServers.push({
    urls: 'turn:global.turn.twilio.com:3478?transport=udp',
    credential: '/8xvWEi0BzBODpksf8I8IrZh+WndbicA95SUlvVcx+o=3',
    username: 'd56ba7a915cc94c2254524cc5a9e931a9a55e3f22e7368379c2805fdf12c5785'
});    
  
// https://www.rtcmulticonnection.org/docs/iceServers/
connection.iceServers.push({
    'urls': [
        'stun:108.177.125.127'
       // 'stun:stun.l.google.com:19302',  
       // 'stun:stun1.l.google.com:19302',
       // 'stun:stun2.l.google.com:19302'
    ]
}); 



// its mandatory in v3
connection.enableScalableBroadcast = true;

// each relaying-user should serve only 5 users
connection.maxRelayLimitPerUser = 5;

// we don't need to keep room-opened
// scalable-broadcast.js will handle stuff itself.
connection.autoCloseEntireSession = true;

// by default, socket.io server is assumed to be deployed on your own URL
connection.socketURL = '/';

// comment-out below line if you do not have your own socket.io server
 connection.socketURL = 'https://muazkhan.com:9001/';

connection.socketMessageEvent = 'scalable-media-broadcast-demo';


// Store the object recognition resulting model in the global scope of our app.
var model = undefined;
let model_face;
// Before we can use COCO-SSD class we must wait for it to finish
// loading. Machine Learning models can be large and take a moment 
// to get everything needed to run.
// Note: cocoSsd is an external object loaded from our index.html
// script tag import so ignore any warning in Glitch.
cocoSsd.load().then(function (loadedModel) {
model = loadedModel;
//console.log(model);

//remove loading icon
loading.classList.add('invisible');
// Show demo section now model is ready to use.
demosSection.classList.remove('invisible');
});


// document.getElementById('broadcast-id').value = connection.userid;

//disable audio
connection.mediaConstraints = {
    video: true,
    audio: false
};



// user need to connect server, so that others can reach him.
connection.connectSocket(function(socket) {
    socket.on('logs', function(log) {
        document.querySelector('h1').innerHTML = log.replace(/</g, '----').replace(/>/g, '___').replace(/----/g, '(<span style="color:red;">').replace(/___/g, '</span>)');
    });

    // this event is emitted when a broadcast is already created.
    socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
        console.log('join-broadcaster', hintsToJoinBroadcast);

        connection.session = hintsToJoinBroadcast.typeOfStreams;
        connection.sdpConstraints.mandatory = {
            OfferToReceiveVideo: !!connection.session.video,
            OfferToReceiveAudio: !!connection.session.audio
        };
        connection.broadcastId = hintsToJoinBroadcast.broadcastId;
        connection.join(hintsToJoinBroadcast.userid);
    });

    socket.on('rejoin-broadcast', function(broadcastId) {
        console.log('rejoin-broadcast', broadcastId);
      
        connection.attachStreams = [];
        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
            if (!isBroadcastExists) {
                roomopened=false;
            
              alert("EIE4428 Project Broadcast not yet start.");
              return;
                // connection.userid = broadcastId;
            } else{
           roomopened=true;
            socket.emit('join-broadcast', {
                broadcastId: broadcastId,
                userid: connection.userid,
                typeOfStreams: connection.session
            });
        }
        });
    });

    socket.on('broadcast-stopped', function(broadcastId) {
        // alert('Broadcast has been stopped.');
        // location.reload();
        console.error('broadcast-stopped', broadcastId);
        alert('This broadcast has been stopped.');
    });

    // this event is emitted when a broadcast is absent.
    socket.on('start-broadcasting', function(typeOfStreams) {
        console.log('start-broadcasting', typeOfStreams);

        // host i.e. sender should always use this!
        connection.sdpConstraints.mandatory = {
            OfferToReceiveVideo: false,
            OfferToReceiveAudio: false
        };
        connection.session = typeOfStreams;

        // "open" method here will capture media-stream
        // we can skip this function always; it is totally optional here.
        // we can use "connection.getUserMediaHandler" instead
        connection.open(connection.userid);
    });
});

//when refresh broswer
window.onbeforeunload = function() {
    document.getElementById('open-or-join').disabled = false;
};

let canvas_face = document.getElementById('canvas_face');


var videoPreview = document.getElementById('video-preview');
videoPreview.setAttribute('playsinline', '');
var videoOutput = document.getElementById('videoOutput');
videoOutput.setAttribute('playsinline', '');
var videoRecord = document.getElementById('video-record');
videoRecord.setAttribute('playsinline', '');
const liveView = document.getElementById('liveView');
const demosSection = document.getElementById('demos');
const loading = document.getElementById('loading');
videoOutput.addEventListener('loadeddata', predictWebcam);
videoOutput.addEventListener('loadeddata', recordbuttonenable);
videoOutput.addEventListener('loadeddata', getvideosize);
//videoOutput.addEventListener('loadeddata', test);

videoOutput.addEventListener('loadeddata', function(){faceDetection(this, context_face, videoOutput.ClientWidth, videoOutput.ClientHeight);}, false);



connection.onstream = function(event) {
    if (connection.isInitiator && event.type !== 'local') {
     
        return;
    }
    connection.isUpperUserLeft = false;
    
    videoPreview.srcObject = event.stream;
    
    videoPreview.play();
    
    videoPreview.userid = event.userid;

    if (event.type === 'local') {
        videoPreview.muted = true;      
    }

const canvas = document.getElementById('overlay-canvas');

const context = canvas.getContext('2d');

function drawDateTimeOverlay() {
  // Clear the canvas
  
  context.clearRect(0, 0, canvas.width, canvas.height);

  // Draw the video frame
  context.drawImage(videoPreview, 0, 0, canvas.width, canvas.height);

  // Draw the date-time overlay
  const date = new Date().toLocaleString();
  //context.fillStyle = "grey";
  //context.fillRect(20, 20, 250, 50);
  context.font = '20px serif';
  context.fillStyle = 'red';
  context.fillText(date, 10, 30);

  // Request the next animation frame
  requestAnimationFrame(drawDateTimeOverlay);
}

  

    // Set up the canvas and draw the date-time overlay
    canvas.width = videoOutput.clientWidth;
    canvas.height = videoOutput.clientHeight;
    drawDateTimeOverlay();

    // Capture the canvas as a separate stream
    const canvasStream = canvas.captureStream();

    // Merge the video and canvas streams into a combined stream
    const combinedStream = new MediaStream([...event.stream.getTracks(), ...canvasStream.getTracks()]);

  //  videoPreview.srcObject = combinedStream;
  //  videoPreview.play();
  console.log(event.stream.getTracks()[0].getSettings());
 if(event.stream.getTracks()[0].getSettings().frameRate == undefined){
  
  alert("Your browser is not supported or try to open wifi.")
  disconnect();
}else{
  
   // console.log(event.stream);
   // console.log(canvasStream);
    //console.log(combinedStream);
   
    videoOutput.srcObject =canvasStream;
    videoOutput.play();
}






    if (connection.isInitiator == false && event.type === 'remote') {
      
        // he is merely relaying the media
        connection.dontCaptureUserMedia = true;
        connection.attachStreams = [event.stream];
        connection.sdpConstraints.mandatory = {
            OfferToReceiveAudio: false,
            OfferToReceiveVideo: false
        };

        connection.getSocket(function(socket) {
            socket.emit('can-relay-broadcast');

            if (connection.DetectRTC.browser.name === 'Chrome' || connection.DetectRTC.browser.name === 'Edge' ||  connection.DetectRTC.browser.name === 'Safari') {
                connection.getAllParticipants().forEach(function(p) {
                    if (p + '' != event.userid + '') {
                        var peer = connection.peers[p].peer;
                        peer.getLocalStreams().forEach(function(localStream) {
                            peer.removeStream(localStream);
                        });
                        event.stream.getTracks().forEach(function(track) {
                            peer.addTrack(track, event.stream);
                          
                        });
                        connection.dontAttachStream = true;
                        connection.renegotiate(p);
                        connection.dontAttachStream = false;
                    }
                });
            }

            if (connection.DetectRTC.browser.name === 'Firefox'  || connection.DetectRTC.browser.name === 'Safari') {
                // Firefox is NOT supporting removeStream method
                // that's why using alternative hack.
                // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                // need to ask all deeper nodes to rejoin
                connection.getAllParticipants().forEach(function(p) {
                    if (p + '' != event.userid + '') {
                        connection.replaceTrack(event.stream, p);
                    }
                });
            }

           
        });
    }

    // to keep room-id in cache
    localStorage.setItem(connection.socketMessageEvent, connection.sessionid);
   console.log(connection.codecs.video);
  };

// ask node.js server to look for a broadcast
// if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
// if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
document.getElementById('open-or-join').onclick = function() {
  
    var broadcastId = document.getElementById('broadcast-id').value;
    if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
        alert('Please enter broadcast-id');
        document.getElementById('broadcast-id').focus();
        return;
    }
    

    connection.extra.broadcastId = broadcastId;

    connection.session = {
        audio: false,
        video: true,
        oneway: true,
        data: true
    };

    connection.getSocket(function(socket) {
        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
            if (!isBroadcastExists) {
                roomopened=false;           
              alert("EIE4428 Project Broadcast not yet start.");
              document.getElementById('open-or-join').disabled = false;
              return;
                // connection.userid = broadcastId;
            } else{
            
            roomopened=true;  
            document.getElementById('open-or-join').disabled = true;  
            console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

            socket.emit('join-broadcast', {
                broadcastId: broadcastId,
                userid: connection.userid,
                typeOfStreams: connection.session
            });
           
            
            document.getElementById('change-size').disabled = false; 
            document.getElementById('reset-size').disabled = false; 
            document.getElementById('clear-button').disabled = false; 
            document.getElementById('clear-button2').disabled = false; 
            document.getElementById('objectRecognizeOn').disabled = false; 
           // document.getElementById('objectRecognizeOff').disabled = false; 
            document.getElementById('FaceTrackingOn').disabled = false; 
            //document.getElementById('FaceTrackingOff').disabled = false; 


            document.getElementById('photo-filter').disabled = false; 
            document.getElementById('grayscale').disabled = false; 
            document.getElementById('sepia').disabled = false; 
            document.getElementById('invert').disabled = false; 
            document.getElementById('brightness').disabled = false; 
            document.getElementById('opacity').disabled = false; 
            document.getElementById('contrast').disabled = false; 
            document.getElementById('saturate').disabled = false; 
        }
        });
    });
};

connection.onstreamended = function() {};

connection.onleave = function(event) {
    if (event.userid !== videoPreview.userid) return;

    connection.getSocket(function(socket) {
        socket.emit('can-not-relay-broadcast');

        connection.isUpperUserLeft = true;

        if (allRecordedBlobs.length) {
            // playing lats recorded blob
            var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
            videoOutput.src = URL.createObjectURL(lastBlob);
            videoOutput.play();
            allRecordedBlobs = [];
        } else if (connection.currentRecorder) {
            var recorder = connection.currentRecorder;
            connection.currentRecorder = null;
            recorder.stopRecording(function() {
                if (!connection.isUpperUserLeft) return;

                videoOutput.src = URL.createObjectURL(recorder.getBlob());
                videoOutput.play();
            });
        }

        if (connection.currentRecorder) {
            connection.currentRecorder.stopRecording();
            connection.currentRecorder = null;
        }
    });
};

var allRecordedBlobs = [];
var timergoing = false;
function repeatedlyRecordStream(stream) {
    if (!enableRecordings) {
        return;
    }

    timergoing = true;
    connection.currentRecorder = RecordRTC(stream, {
        type: 'video'
    });
  
    connection.currentRecorder.startRecording();

    setTimeout(function() {
        if (connection.isUpperUserLeft || !connection.currentRecorder) {
            return;
        }

        connection.currentRecorder.stopRecording(function() {
            allRecordedBlobs.push(connection.currentRecorder.getBlob());

            if (connection.isUpperUserLeft) {
                return;
            }

            connection.currentRecorder = null;
            repeatedlyRecordStream(event.stream);
        });
    }, 61 * 1000); // 61-seconds max
    
   setTimeout(function() {
    if (timergoing==true){
      stoprecord();
      alert("Recording Stopped! Maximum recording time is 60 seconds.");
    }
    }, 60 * 1000);
};

document.getElementById("recording").addEventListener('click', record);
document.getElementById("stoprecording").addEventListener('click', stoprecord);
document.getElementById("showrecording").addEventListener('click', showrecord);
function record() {
            document.getElementById('recording').disabled = true; 
            document.getElementById('stoprecording').disabled = false; 
           document.getElementById('spinner-grow').classList.remove("d-none");
            // Firefox seems UN_ABLE to record remote MediaStream
            // WebAudio solution merely records audio
            // so recording is skipped for Firefox.
            if (connection.DetectRTC.browser.name === 'Chrome' || connection.DetectRTC.browser.name === 'Edge'  || connection.DetectRTC.browser.name === 'Safari') {
                repeatedlyRecordStream(videoOutput.srcObject);
            }

        }

function stoprecord(){
            connection.currentRecorder.stopRecording();     
            document.getElementById('showrecording').disabled = false; 
            document.getElementById('stoprecording').disabled = true; 
            timergoing= false;
            document.getElementById('spinner-grow').classList.add("d-none");
        }
        
function showrecord(){
    
            if( connection.currentRecorder.getBlob() != null){
            allRecordedBlobs.push(URL.createObjectURL(connection.currentRecorder.getBlob())); 
            videoRecord.classList.remove("d-none");  
            videoRecord.src = URL.createObjectURL(connection.currentRecorder.getBlob());
            videoRecord.play();
            document.getElementById('showrecording').disabled = true;  
            document.getElementById('recording').disabled = false; 
            showAllrecording();
            } else{
            alert("Please try again. Recording video is still loading");
            document.getElementById('showrecording').disabled = false;  
            document.getElementById('recording').disabled = false; 
            }       
}

function showAllrecording(){
  var records = allRecordedBlobs;
  records.sort();

  var recordsHTML = records.map(record => `<a href="${record}" target="_blank">${record}</a>`).join('<br>');
  
  document.getElementById('recording_content').innerHTML =recordsHTML;
  
  //console.log(allRecordedBlobs)
}


function recordbuttonenable(){
            document.getElementById('recording').disabled = false; 
            document.getElementById('accordionExample').classList.remove("d-none");
}



function disableInputButtons() {
    document.getElementById('open-or-join').disabled = true;
    document.getElementById('broadcast-id').disabled = true;
}

function disconnect() {
    window.location.reload();   
}

//const supports = navigator.mediaDevices.getSupportedConstraints();

var VideoStartWidth = 0;
var VideoStartHeight =0;

var CurrentVideoWidth = 0;
var CurrentVideoHeight =0;

//var BeforeVideoWidth = 0;
//var BeforeVideoHeight =0;

var finalVideoWidth = 1; //scale factor
var finalVideoHeight = 1;//scale factor

function getvideosize(){
   VideoStartWidth = videoOutput.clientWidth;
   VideoStartHeight = videoOutput.clientHeight;
   
   CurrentVideoWidth =  videoOutput.clientWidth;
CurrentVideoHeight = videoOutput.clientHeight;
}




function videoSize(){
  var width = document.getElementById("vid-width").value;
  var height = document.getElementById("vid-height").value;
//console.log("w "+ width2+"; h "+height2);

document.getElementById("initial_WH").innerHTML = "Previous Width="+videoOutput.clientWidth+ "; Previous Height="+videoOutput.clientHeight;
//console.log("Start: H="+VideoStartHeight+"; W="+VideoStartWidth);
//console.log("current: H="+videoPreview.clientHeight+"; W="+videoPreview.clientWidth);

//BeforeVideoWidth = videoOutput.clientWidth;
//BeforeVideoHeight = videoOutput.clientHeight;

//if(width<=VideoStartWidth)     {
  videoOutput.width = width;
//}        

//if(width<=VideoStartHeight)     {
  videoOutput.height = height;
//}  

canvas_face.width = width;
canvas_face.height = height-50;

CurrentVideoWidth =  width;
CurrentVideoHeight = height;

/*
  var constraints = {};
  if (supports.width && supports.height) {
      constraints = {
          width: width,
          height: height
      };
  }

  connection.applyConstraints({
      video: constraints
  }); */
   finalVideoWidth = CurrentVideoWidth/VideoStartWidth;
   finalVideoHeight = CurrentVideoHeight/VideoStartHeight;
}

function resetSize(){
  videoOutput.width = VideoStartWidth;
  videoOutput.height = VideoStartHeight;
  //canvas_face.width = VideoStartWidth;
  //canvas_face.height = VideoStartHeight;
  finalVideoWidth =1;
  finalVideoHeight =1;
}

document.getElementById("disconnect-button").addEventListener('click', disconnect);
document.getElementById('change-size').addEventListener('click', videoSize);
document.getElementById('reset-size').addEventListener('click', resetSize);

// ......................................................
// ......................Handling broadcast-id................
// ......................................................
/*
var broadcastId = '';
if (localStorage.getItem(connection.socketMessageEvent)) {
    broadcastId = localStorage.getItem(connection.socketMessageEvent);
} else {
    broadcastId = connection.token();
}
var txtBroadcastId = document.getElementById('broadcast-id');
txtBroadcastId.value = broadcastId;
txtBroadcastId.onkeyup = txtBroadcastId.oninput = txtBroadcastId.onpaste = function() {
    localStorage.setItem(connection.socketMessageEvent, this.value);
}; */

//////////////////Advanced///////////////////////////////////

let objectRecognizeBool = false;
let faceTrackingBool = false;

document.getElementById("objectRecognizeOn").addEventListener("click", function(){
  
    objectRecognizeBool = true;
   // console.log("1: "+objectRecognizeBool);
    document.getElementById("objectRecognizeOn").classList.remove("btn-primary");
    document.getElementById("objectRecognizeOn").classList.add("btn-secondary");
    document.getElementById("objectRecognizeOff").classList.remove("btn-secondary");
    document.getElementById("objectRecognizeOff").classList.add("btn-primary");
    document.getElementById("objectRecognizeOn").disabled = true;
    document.getElementById("objectRecognizeOff").disabled = false;
   // window.requestAnimationFrame(predictWebcam);
     setTimeout(function() {
        
       predictWebcam();
      }, 1200)
});

document.getElementById("objectRecognizeOff").addEventListener("click", function(){
   
    objectRecognizeBool = false;
    for (let i = 0; i < children.length; i++) {
      liveView.removeChild(children[i]);
    }
    children.splice(0);

    //console.log("2: "+objectRecognizeBool);
    document.getElementById("objectRecognizeOff").classList.remove("btn-primary");
    document.getElementById("objectRecognizeOff").classList.add("btn-secondary");
    document.getElementById("objectRecognizeOn").classList.remove("btn-secondary");
    document.getElementById("objectRecognizeOn").classList.add("btn-primary");
    document.getElementById("objectRecognizeOff").disabled = true;
    document.getElementById("objectRecognizeOn").disabled = false;
   // window.cancelAnimationFrame(predictWebcam);
  clearTimeout(predictWebcam);
});
////////////////////////////////////////////////////////////////////

document.getElementById("FaceTrackingOn").addEventListener("click", function(){
  
  faceTrackingBool = true;

  document.getElementById("FaceTrackingOn").classList.remove("btn-primary");
  document.getElementById("FaceTrackingOn").classList.add("btn-secondary");
  document.getElementById("FaceTrackingOff").classList.remove("btn-secondary");
  document.getElementById("FaceTrackingOff").classList.add("btn-primary");
  document.getElementById("FaceTrackingOn").disabled = true;
  document.getElementById("FaceTrackingOff").disabled = false;
  
  faceDetection(videoOutput, context_face, videoOutput.ClientWidth, videoOutput.ClientHeight);
    }, false);


document.getElementById("FaceTrackingOff").addEventListener("click", function(){
 
  faceTrackingBool = false;


  document.getElementById("FaceTrackingOff").classList.remove("btn-primary");
  document.getElementById("FaceTrackingOff").classList.add("btn-secondary");
  document.getElementById("FaceTrackingOn").classList.remove("btn-secondary");
  document.getElementById("FaceTrackingOn").classList.add("btn-primary");
  document.getElementById("FaceTrackingOff").disabled = true;
  document.getElementById("FaceTrackingOn").disabled = false;
  clearTimeout(faceDetection,250,videoOutput,context_face,CurrentVideoWidth,CurrentVideoHeight);
});

//////////////////Advanced///////////////////////////////////

var children = [];

function predictWebcam() {
 
    //console.log(objectRecognizeBool);
  // Now let's start classifying a frame in the stream.
  model.detect(videoOutput).then(function (predictions) { //cannot change to videoOutput
    // Remove any highlighting we did previous frame.
    for (let i = 0; i < children.length; i++) {
      liveView.removeChild(children[i]);
    }
    children.splice(0);


    if (objectRecognizeBool==true) {
    // Now lets loop through predictions and draw them to the live view if
    // they have a high confidence score.
   /*if(finalVideoWidth!=0){
    
    console.log(finalVideoWidth);
   }*/

  

    for (let n = 0; n < predictions.length; n++) {
      // If we are over 66% sure we are sure we classified it right, draw it!
      if (predictions[n].score > 0.618) {
        const p = document.createElement('p');
        p.setAttribute('class', 'hide_highlighter');
        p.innerText = predictions[n].class  + ' - with ' 
            + Math.round(parseFloat(predictions[n].score) * 100) 
            + '% confidence.';
        p.style = 'margin-left: ' + (predictions[n].bbox[0])*finalVideoWidth + 'px; margin-top: '
            + (predictions[n].bbox[1] - 10)*finalVideoHeight + 'px; width: ' 
            + (predictions[n].bbox[2] - 10)*finalVideoWidth + 'px; top: 0; left: 0;';

        const highlighter = document.createElement('div');
        highlighter.setAttribute('class', 'highlighter hide_highlighter');
       
        highlighter.style = 'left: ' + (predictions[n].bbox[0])*finalVideoWidth + 'px; top: '
            + (predictions[n].bbox[1]*finalVideoHeight) + 'px; width: ' 
            + predictions[n].bbox[2]*finalVideoWidth + 'px; height: '
            + predictions[n].bbox[3]*finalVideoHeight + 'px;';

        liveView.appendChild(highlighter);
        liveView.appendChild(p);
        children.push(highlighter);
        children.push(p);
      }
    }
  
    //if (objectRecognizeBool==true) {
    // console.log("running");
    // Call this function again to keep predicting when the browser is ready.
    
     setTimeout(function() {
        //window.requestAnimationFrame(predictWebcam);
       predictWebcam();
      }, 1200)
   //}
  }

  });
}


context_face = canvas_face.getContext('2d');

async function faceDetection(videoOutput, context_face, width, height) {
canvas_face.width = videoOutput.clientWidth;
canvas_face.height = videoOutput.clientHeight-50;
if(!model_face) model_face = await blazeface.load();
if (faceTrackingBool==true){
const prediction = await model_face.estimateFaces(videoOutput, false);

if (prediction.length > 0) {
           // console.log(prediction);
            // Clear the canvas before drawing the new boxes
  context_face.clearRect(0, 0, canvas_face.width, canvas_face.height);

            for (let i = 0; i < prediction.length; i++) {
                const start = prediction[i].topLeft;
                const end = prediction[i].bottomRight;

                var probability = prediction[i].probability;

                const scaledStartX = start[0] * finalVideoWidth;
                const scaledStartY = start[1] * finalVideoHeight ;
                const scaledWidth = (end[0] - start[0]) * finalVideoWidth;
                const scaledHeight = (end[1] - start[1]) * finalVideoHeight;



               // const size = [end[0]*finalVideoHeight - start[0]*finalVideoHeight, end[1]*finalVideoWidth - start[1]*finalVideoWidth];
                // Render a rectangle over each detected face.
                context_face.beginPath();
                context_face.strokeStyle="green";
                context_face.lineWidth = "4";
                context_face.rect(scaledStartX, scaledStartY-50, scaledWidth, scaledHeight);
                context_face.stroke();
                var prob = (probability[0]*100).toPrecision(5).toString();
                var text = prob+"%";
                context_face.fillStyle = "red";
                context_face.font = "13pt sans-serif";
                context_face.fillText(text, scaledStartX + 5, scaledStartY + 20);
    }
        }else{
          context_face.clearRect(0, 0, canvas_face.width, canvas_face.height);
        }
        setTimeout(faceDetection,250,videoOutput,context_face,CurrentVideoWidth,CurrentVideoHeight);
}
}

  const codecPreferences = document.getElementById('codecPreferences');
const supportsSetCodecPreferences = window.RTCRtpTransceiver &&
  'setCodecPreferences' in window.RTCRtpTransceiver.prototype;

  if (supportsSetCodecPreferences) {
    const {codecs} = RTCRtpSender.getCapabilities('video');
    codecs.forEach(codec => {
      if (['video/red', 'video/ulpfec', 'video/rtx'].includes(codec.mimeType)) {
        return;
      }
      const option = document.createElement('option');
      option.disabled = true;
      option.value = (codec.mimeType + ' ' + (codec.sdpFmtpLine || '')).trim();
      option.innerText = option.value;
      codecPreferences.appendChild(option);
    });
    codecPreferences.disabled = false;
  }


/*
async function test(){
  const model_hand = handPoseDetection.SupportedModels.MediaPipeHands;
const detectorConfig = {
  runtime: 'mediapipe', // or 'tfjs'
  modelType: 'full'
};
detector = await handPoseDetection.createDetector(model_hand, detectorConfig);
  const hands = await detector.estimateHands(videoOutput);
  console.log(hands);
}
*/


connection.onmessage = function(event) {

document.getElementById("message_content").innerHTML += ("<small>"+event.userid +"</small> said: "+ event.data+"<br/>");
};

document.getElementById("clear_message").addEventListener('click', clearMessage);

function clearMessage() {
  document.getElementById("message_content").innerHTML = "";
}
  
</script>


  <footer>
    <small id="send-message"></small>
  </footer>

  <script src="https://www.webrtc-experiment.com/common.js"></script>

</body>
</html>
